# -*- coding:utf-8 -*-
"""
题目：圆圈中最后剩下的数
0-n-1这n个数排成一个圆圈，从0开始在圆圈中删除第m个数，求圆圈中剩余的最后一个数字

思路1：
构建一个环形链表，将尾结点链接到头结点

思路2：
使用动态规划。我们注意到，输入的序列在删除一个元素后，序列的长度会改变，如果索引
在被删除的元素位置开始计算，那么每删除一个元素，序列的长度减一而索引会完全改变。
如果能找到改变前的索引和新索引的对应关系，那么该问题就容易解决了。
我们定义一个函数f(n, m)，表示每次在n个数字0,1,2,3,…,n-1中每次删除第m个数字后剩下
的数字。那么第一个被删除的数字的索引是(m-1)%n。删除该索引元素后，剩下的n-1个数字
为0,1,2,…,k-1,k+1,…,n-1。下次删除数字是重k+1位置开始，于是可以把序列看
作k+1,..,n-1,0,1,…,k-1。该序列最后剩下的序列也是f的函数。但该函数和第一个函数
不同，存在映射关系，使用f'来表示，于是有：f(n, m)=f'(n-1, m)。接下来需要找到映射关系。
k+1 --> 0
k+2 --> 1
     .
     .
     .
n-1 --> n-k-2
0   --> n-k-1
     .
     .
     .
k-1 --> n-2
所以可以得到：right = left-k-1，则p(x) = (x-k-1)%n，而逆映射是p'(x) = (x+k+1)%n
即0~n-1序列中最后剩下的数字等于（0~n-2序列中最后剩下的数字+k）%n，很明显当n=1时，
只有一个数，那么剩下的数字就是0.问题转化为动态规划问题，关系表示为：
f(n)=(f(n-1)+m)%n  n>1； 
f(1)=0 n=1;
"""
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if n < 1 or m < 1:
            return -1
        last = 0
        for i in range(2, n+1):
            last = (last+m)%i
        return last
